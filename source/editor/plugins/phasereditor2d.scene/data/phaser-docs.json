{
  "Phaser.GameObjects.Image": "An Image Game Object.\n\nAn Image is a light-weight Game Object useful for the display of static images in your game,\nsuch as logos, backgrounds, scenery or other non-animated elements. Images can have input\nevents and physics bodies, or be tweened, tinted or scrolled. The main difference between an\nImage and a Sprite is that you cannot animate an Image as they do not have the Animation component.",
  "Phaser.GameObjects.Sprite": "A Sprite Game Object.\n\nA Sprite Game Object is used for the display of both static and animated images in your game.\nSprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\nand animated.\n\nThe main difference between a Sprite and an Image Game Object is that you cannot animate Images.\nAs such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\nComponent. If you do not require animation then you can safely use Images to replace Sprites in all cases.",
  "Phaser.GameObjects.Container": "A Container Game Object.\n\nA Container, as the name implies, can 'contain' other types of Game Object.\nWhen a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\nBy default it will be removed from the Display List and instead added to the Containers own internal list.\n\nThe position of the Game Object automatically becomes relative to the position of the Container.\n\nThe origin of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\nContainer should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\nthe Container, and position children positively and negative around it as required.\n\nWhen the Container is rendered, all of its children are rendered as well, in the order in which they exist\nwithin the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\n\nIf you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\nautomatically influence all children as well.\n\nContainers can include other Containers for deeply nested transforms.\n\nContainers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\nThe masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\n\nContainers can be enabled for input. Because they do not have a texture you need to provide a shape for them\nto use as their hit area. Container children can also be enabled for input, independent of the Container.\n\nContainers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\nif Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\nif the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\nwith physics do not factor in the Container due to the excessive extra calculations needed. Please structure\nyour game to work around this.\n\nIt's important to understand the impact of using Containers. They add additional processing overhead into\nevery one of their children. The deeper you nest them, the more the cost escalates. This is especially true\nfor input events. You also loose the ability to set the display depth of Container children in the same\nflexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\nevery time you create one, try to structure your game around avoiding that where possible.",
  "Phaser.GameObjects.Components.Transform.x": "The x position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.y": "The y position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.setPosition": "Sets the position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleX": "The horizontal scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleY": "The vertical scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.angle": "The angle of this Game Object as expressed in degrees.\n\nPhaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\nand -90 is up.\n\nIf you prefer to work in radians, see the `rotation` property instead.",
  "Phaser.GameObjects.Components.Origin.originX": "The horizontal origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the left of the Game Object.",
  "Phaser.GameObjects.Components.Origin.originY": "The vertical origin of this Game Object.\nThe origin maps the relationship between the size and position of the Game Object.\nThe default value is 0.5, meaning all Game Objects are positioned based on their center.\nSetting the value to 0 means the position now relates to the top of the Game Object.",
  "Phaser.GameObjects.Components.Origin.setOrigin": "Sets the origin of this Game Object.\n\nThe values are given in the range 0 to 1.",
  "Phaser.GameObjects.Components.Alpha.alpha": "The alpha value of the Game Object.\n\nThis is a global value, impacting the entire Game Object, not just a region of it.",
  "Phaser.GameObjects.Components.Alpha.alphaTopLeft": "The alpha value starting from the top-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaTopRight": "The alpha value starting from the top-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomLeft": "The alpha value starting from the bottom-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomRight": "The alpha value starting from the bottom-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Flip.flipX": "The horizontally flipped state of the Game Object.\n\nA Game Object that is flipped horizontally will render inversed on the horizontal axis.\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Flip.flipY": "The vertically flipped state of the Game Object.\n\nA Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\nFlipping always takes place from the middle of the texture and does not impact the scale value.\nIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Visible.visible": "The visible state of the Game Object.\n\nAn invisible Game Object will skip rendering, but will still process update logic.",
  "Phaser.GameObjects.Components.Tint.tint": "The tint value being applied to the whole of the Game Object.\nThis property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.",
  "Phaser.GameObjects.Components.Tint.tintFill": "Fill or additive?",
  "Phaser.GameObjects.Components.Tint.tintTopLeft": "The tint value being applied to the top-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Tint.tintTopRight": "The tint value being applied to the top-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Tint.tintBottomLeft": "The tint value being applied to the bottom-left of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Tint.tintBottomRight": "The tint value being applied to the bottom-right of the Game Object.\nThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.TileSprite": "A TileSprite is a Sprite that has a repeating texture.\n\nThe texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\nare designed so that you can create game backdrops using seamless textures as a source.\n\nYou shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\nthat scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\nproperty to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will \nconsume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\nadjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\n\nAn important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\nseamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\nthey need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\nTileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\nscaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\nany size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\ndue to the interpolation that took place when it was resized into a POT texture. This is especially visible in\npixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\nprovide POT textures for Tile Sprites.",
  "Phaser.GameObjects.Components.ComputedSize.width": "The native (un-scaled) width of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayWidth` property.",
  "Phaser.GameObjects.Components.ComputedSize.height": "The native (un-scaled) height of this Game Object.\n\nChanging this value will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or use\nthe `displayHeight` property.",
  "Phaser.GameObjects.Components.ComputedSize.setSize": "Sets the internal size of this Game Object, as used for frame or physics body creation.\n\nThis will not change the size that the Game Object is rendered in-game.\nFor that you need to either set the scale of the Game Object (`setScale`) or call the\n`setDisplaySize` method, which is the same thing as changing the scale but allows you\nto do so by giving pixel values.\n\nIf you have enabled this Game Object for input, changing the size will _not_ change the\nsize of the hit area. To do this you should adjust the `input.hitArea` object directly.",
  "Phaser.GameObjects.TileSprite.tilePositionX": "The horizontal scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.tilePositionY": "The vertical scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.setTilePosition": "Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.",
  "Phaser.GameObjects.TileSprite.tileScaleX": "The horizontal scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.tileScaleY": "The vertical scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.setTileScale": "Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.",
  "Phaser.GameObjects.GameObject.parentContainer": "The parent Container of this Game Object, if it has one.",
  "Phaser.GameObjects.Text": "A Text Game Object.\n\nText objects work by creating their own internal hidden Canvas and then renders text to it using\nthe standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\nto your game during the render pass.\n\nBecause it uses the Canvas API you can take advantage of all the features this offers, such as\napplying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\nloaded externally, such as Google or TypeKit Web fonts.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters, either when creating the Text object, or when setting the font via `setFont`\nor `setFontFamily`, e.g.:\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\n```\n\n```javascript\nthis.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\n```\n\nYou can only display fonts that are currently loaded and available to the browser: therefore fonts must\nbe pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\nor have the fonts ready available in the CSS on the page in which your Phaser game resides.\n\nSee {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\nacross mobile browsers.\n\nA note on performance: Every time the contents of a Text object changes, i.e. changing the text being\ndisplayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\nnew texture to the GPU. This can be an expensive operation if used often, or with large quantities of\nText objects in your game. If you run into performance issues you would be better off using Bitmap Text\ninstead, as it benefits from batching and avoids expensive Canvas API calls.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedWidth": "Force the Text object to have the exact width specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedHeight": "Force the Text object to have the exact height specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.GameObjects.TextStyle.setFixedSize": "Set a fixed width and height for the text.\n\nPass in `0` for either of these parameters to disable fixed width or height respectively.",
  "Phaser.GameObjects.Text.setPadding": "Set the text padding.\n\n'left' can be an object.\n\nIf only 'left' and 'top' are given they are treated as 'x' and 'y'.",
  "Phaser.Types.GameObjects.Text.TextPadding.left": "The amount of padding added to the left of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.top": "The amount of padding added to the top of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.right": "The amount of padding added to the right of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.bottom": "The amount of padding added to the bottom of the Text object.",
  "Phaser.GameObjects.Text.lineSpacing": "The line spacing value.\nThis value is added to the font height to calculate the overall line height.\nOnly has an effect if this Text object contains multiple lines of text.\n\nIf you update this property directly, instead of using the `setLineSpacing` method, then\nbe sure to call `updateText` after, or you won't see the change reflected in the Text object.",
  "Phaser.GameObjects.Text.setAlign": "Set the alignment of the text in this Text object.\n\nThe argument can be one of: `left`, `right`, `center` or `justify`.\n\nAlignment only works if the Text object has more than one line of text.",
  "Phaser.GameObjects.Text.setFontFamily": "Set the font family.\n\n**Important:** The font name must be quoted if it contains certain combinations of digits or\nspecial characters:\n\n```javascript\nText.setFont('\"Press Start 2P\"');\n```\n\nEqually, if you wish to provide a list of fallback fonts, then you should ensure they are all\nquoted properly, too:\n\n```javascript\nText.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\n```",
  "Phaser.GameObjects.Text.setFontSize": "Set the font size.",
  "Phaser.GameObjects.Text.setFontStyle": "Set the font style.",
  "Phaser.GameObjects.Text.setColor": "Set the text fill color.",
  "Phaser.GameObjects.Text.setStroke(color)": "The stroke color.",
  "Phaser.GameObjects.Text.setStroke(thickness)": "The stroke thickness.",
  "Phaser.GameObjects.Text.setBackgroundColor": "Set the background color.",
  "Phaser.GameObjects.Text.setShadowOffset": "Set the shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(x)": "The horizontal shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(y)": "The vertical shadow offset.",
  "Phaser.GameObjects.Text.setShadowStroke": "Enable or disable shadow stroke.",
  "Phaser.GameObjects.Text.setShadowFill": "Enable or disable shadow fill.",
  "Phaser.GameObjects.Text.setShadowColor": "Set the shadow color.",
  "Phaser.GameObjects.Text.setShadowBlur": "Set the shadow blur radius.",
  "Phaser.GameObjects.TextStyle.baselineX": "The amount of horizontal padding added to the width of the text when calculating the font metrics.",
  "Phaser.GameObjects.TextStyle.baselineY": "The amount of vertical padding added to the height of the text when calculating the font metrics.",
  "Phaser.GameObjects.Text.setMaxLines": "Set the maximum number of lines to draw.",
  "Phaser.GameObjects.BitmapText": "BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\n\nDuring rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\nmatch the font structure.\n\nBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\nto use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\nprocessing the font texture in an image editor, applying fills and any other effects required.\n\nTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\n\nTo create a BitmapText data files you need a 3rd party app such as:\n\nBMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\nGlyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\nLittera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\n\nFor most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\nconverting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}",
  "Phaser.GameObjects.BitmapText.setFont": "Changes the font this BitmapText is using to render.\n\nThe new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\nunless overridden via the arguments.",
  "Phaser.GameObjects.BitmapText.align": "Controls the alignment of each line of text in this BitmapText object.\n\nOnly has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\nHas no effect with single-lines of text.\n\nSee the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\n\n0 = Left aligned (default)\n1 = Middle aligned\n2 = Right aligned\n\nThe alignment position is based on the longest line of text.",
  "Phaser.GameObjects.BitmapText.setFontSize": "Set the font size of this Bitmap Text.",
  "Phaser.GameObjects.BitmapText.setLetterSpacing": "Sets the letter spacing between each character of this Bitmap Text.\nCan be a positive value to increase the space, or negative to reduce it.\nSpacing is applied after the kerning values have been set.",
  "Phaser.Tilemaps.Tilemap": "A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\nabout the map and allows you to add tilesets and tilemap layers to it. A map can have one or\nmore tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display\nobjects that actually render tiles.\n\nThe Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\nsoftware package specifically for creating tile maps, and is available from:\nhttp://www.mapeditor.org\n\nA Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only\nuse the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.\n\nNote that all Tilemaps use a base tile size to calculate dimensions from, but that a\nStaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides\nit.\n\nAs of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\nwill be traversed and the following properties will affect children:\n- opacity (blended with parent) and visibility (parent overrides child)\n- Vertical and horizontal offset\nThe grouping hierarchy is not preserved and all layers will be flattened into a single array.\nGroup layers are parsed during Tilemap construction but are discarded after parsing so dynamic\nlayers will NOT continue to be affected by a parent.\n\nTo avoid duplicate layer names, a layer that is a child of a group layer will have its parent\ngroup name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\nchild called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\n'ParentGroup/Layer 1'.",
  "Phaser.Tilemaps.Tilemap.tileWidth": "The base width of a tile in pixels. Note that individual layers may have a different tile\nwidth.",
  "Phaser.Tilemaps.Tilemap.tileHeight": "The base height of a tile in pixels. Note that individual layers may have a different\ntile height.",
  "Phaser.GameObjects.GameObjectFactory.tilemap(key)": "The key in the Phaser cache that corresponds to the loaded tilemap data.",
  "Phaser.Tilemaps.Tileset": "A Tileset is a combination of an image containing the tiles and a container for data about\neach tile.",
  "Phaser.Tilemaps.Tileset.name": "The name of the Tileset.",
  "Phaser.Tilemaps.Tileset.image": "The cached image that contains the individual tiles. Use setImage to set.",
  "Phaser.Tilemaps.Tileset.tileWidth": "The width of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileHeight": "The height of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileMargin": "The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.Tileset.tileSpacing": "The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.StaticTilemapLayer": "A Static Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\nwith one, or more, Tilesets.\n\nA Static Tilemap Layer is optimized for rendering speed over flexibility. You cannot apply per-tile\neffects like tint or alpha, or change the tiles or tilesets the layer uses.\n\nUse a Static Tilemap Layer instead of a Dynamic Tilemap Layer when you don't need tile manipulation features.",
  "Phaser.Tilemaps.DynamicTilemapLayer": "A Dynamic Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\nwith one, or more, Tilesets.\n\nA Dynamic Tilemap Layer trades some speed for being able to apply powerful effects. Unlike a\nStatic Tilemap Layer, you can apply per-tile effects like tint or alpha, and you can change the\ntiles in a DynamicTilemapLayer.\n\nUse this over a Static Tilemap Layer when you need those features."
}